본 프로젝트는 인하대학교 INAIR의 STM32 FC를 바탕으로 진행되었습니다.  
https://github.com/NARAE-INHA-UNIV/STM32-FC

기존 코드를 작성해주신 분들의 노력 덕분에
드론 제어 구조와 시스템 흐름을 깊이 이해할 수 있었고,
이를 기반으로 학습과 개선을 이어갈 수 있었습니다.

기존 코드 작성자분들께 감사의 뜻을 전합니다.

---
# IMU–AHRS–SERVO dt 동기화   
수정일: 2026.02.04
---

## 1. 기존 구조 및 문제점

- 메인 제어 루프 주기: **약 70 µs (14.3 kHz)**
- IMU(ICM42688P) 센서 출력 주기: **약 1 ms (1 kHz)**

### 문제 상황
메인 루프가 IMU 갱신 주기보다 훨씬 빠르게 동작하면서,
- 동일한 IMU 샘플을 여러 번 사용
- 실제 물리 시간과 맞지 않는 `dt`가 생성됨
- AHRS 적분, Rate PID에서 시간축 붕괴 발생

그 결과:
- AHRS 각도 적분 불안정
- pid의 부정확한 반응
- 제어 응답의 일관성 저하
- angle은 큰 문제가없는데 rate제어가 거의 먹통임. 반응이 없음 

## 2. 수정 목표

- `dt` 기준을 **루프 주기**가 아닌 **IMU 실제 갱신 주기**로 통일
- IMU가 **새 데이터를 줄 때만**
  - AHRS 업데이트
  - Servo / Rate PID 계산 수행
- IMU → AHRS → SERVO의 **단방향 동기화 구조** 확립


## 3. IMU 갱신 판정 방식
- IMU에서 이미 새로운값을 갱신되면 IMU의 temp(0x2D레지스터)의 3번째 비트가 1이됨. 레지스터 한번 읽으면 다시 0이되는구조(read-to-clear).
- 한번읽고 다시 1이될때까지 dt를 누적시킴 -> 그러면 새로운 값이 갱신되는 정확한 dt를 측정할 수 있음.  ICM42688P_dataReady(void) 참조.
- IMU 드라이버에서 다음 정보를 명확히 분리하여 관리
  - `imu_new_sample` : 새로운 IMU 샘플 도착 여부
  - `dt_imu` : 이전 IMU 샘플과의 실제 시간 간격

### 동작 개념
- msg.raw_imu.time_usec 기반으로 `dt_imu` 계산
- **새 IMU 샘플이 들어온 경우에만**
  - `imu_new_sample = 1` 설정
- AHRS / SERVO는 해당 플래그를 **읽기만 하고 직접 변경하지 않음**

 모든 시간 계산의 기준을 **IMU 물리 시간**으로 통일


## 4. AHRS – SERVO 연동 구조

### 메인 루프 동작 방식

- 메인 루프는 계속 빠르게 순환
- 실제 제어 연산은 **IMU 이벤트 기반으로만 수행**

### 처리 흐름
1. `AHRS_GetData()` 내부에서 IMU 데이터 갱신 시도
2. 새 IMU 샘플이 없으면 AHRS 계산 스킵
3. 새 IMU 샘플이 있으면:
   - 해당 `dt_imu`로 AHRS 적분 수행
4. Servo 제어 역시:
   - `imu_new_sample == 1`일 때만 실행


## 5. IMU 샘플 소비 규칙 정리

- `imu_new_sample`은 **한 IMU 주기당 한 번만 소비**
- AHRS + Servo 계산이 모두 끝난 뒤
  - 메인 루프 말미에서 플래그 clear
- AHRS / Servo 내부에서는 플래그를 변경하지 않음 (읽기 전용)

 동일 IMU 샘플의 중복 사용을 구조적으로 차단

## 6. 결과

- `dt`가 물리적으로 의미 있는 값으로 통일됨
- AHRS 적분 안정화
- Rate PID 응답 일관성 확보
- IMU–AHRS–SERVO가 동일한 시간축에서 동작




---
# 업데이트 2026.01.13 - 호버링 안정성 확보를 위한 AHRS 및 제어 로직 수정
---

## 1. AHRS 변경 사항

### 1.1 기존 AHRS_getData() 코드의 문제점 분석 

* **ms 단위의 시간 분해능:** :  AHRS_getData() 함수는 초당 500에서 800번 이상 실행됩니다. 그런데 ms(밀리초) 단위를 쓰면 dt가 고작 1에서 2 정도로 찍힙니다. 이 거친 해상도로는 적분 오차가 발생해서 정확도가 떨어집니다. timer14 cnt 캡처식 us초로 교체했습니다. 캡처식이 인터럽트식보다 훨씬 신뢰성이 높습니다.
  
* **불필요한 쿼터니언/칼만 계산(출력 미사용):** 기존 코드에는 LKF_Update()를 포함한 쿼터니언 업데이트 로직이 존재하지만, 최종 제어 입력으로 사용하는 RPY(msg.attitude)에는 필터 후 쿼터니언이 반영되지 않고 가속도·지자계 기반 Euler 값이 그대로 사용되었습니다. 결과적으로 쿼터니언/칼만 계산은 제어 출력에 기여하지 못한 채 연산 복잡도와 디버깅 난이도만 증가시키므로, 현재 단계에서는 해당 경로를 제거하고 RPY 경로를 단순화합니다.

* **!RPY 출력이 IMU 자이로를 안쓰고 IMU 가속도만 쓰고있음!:** IMU는 자이로와 가속도를 측정할 수 있습니다. 하지만 현재 코드는 IMU의 가속도만 사용합니다. IMU의 가속도값은 드론이 가만히 있을때만 의미가 있는 값이고(중력 기준으로 자세를 알려주는데 가속도가 가해지는 움직이거나 진동으로 중력 외의 가속도가 가해지는 상황이라면 자신의 자세를 알수없음), 실제 제어에는 자이로(각속도)가 더 중요합니다. 드론은 자이로 적분으로 빠른 자세 변동에 대응하고, 가속도(중력 기준)로 장기 드리프트 보정을 하는 상보필터 구조를 사용합니다. 이건 아래에 따로 설명하겠습니다. 
  
* **출력 RPY에 대한 필터 부재로 노이즈 과다(진동 취약):** 기존 구조에서 실제 출력 RPY는 가속도·지자계로 계산한 Euler에 직접 의존했기 때문에, 멀티콥터 진동/가속 환경에서 roll/pitch/yaw가 쉽게 흔들렸습니다. 이 노이즈가 그대로 PID에 입력되면서 특히 D항이 노이즈를 증폭시켜 이륙이 어려워지는 문제가 발생했습니다. 

* **지자계(Mag) 운용 전략 수정:** 기존에는 지자계를 적극 사용하려 했으나, 현재는 정확성이 부족하여 배제했습니다. 차후 호버링이 검증되면 **절대 헤딩 보정용**으로만 제한적으로 차용할 예정입니다.

### 1.2 상보필터(Complementary Filter)을 적용
상보필터는단기적으로는 자이로 적분값(빠르고 매끄러운 응답)을 중심으로 자세를 추정하고, 장기적으로는 가속도 기반 각도(중력 기준의 절대 안정성)를 저주파 성분으로 천천히 섞어 자이로 드리프트를 억제합니다. 오일러각으로 드론을 제어하려면, RPY를 만들 때 자이로·가속도를 결합하는 자세 추정/필터가 필수입니다.

현재 비율은 아래와 같습니다.

자이로 적분(고주파, 빠른 반응) → 98%

가속도 기반 절대각(저주파, 장기 안정) → 2%

즉, 가속도 기반 각도가 흔들려도 그 흔들림이 RPY 출력으로 바로 튀어 들어오지 않게 만들고, 대신 드리프트만 천천히 잡습니다.

“자이로의 빠릿함(고주파) + 가속도의 안정성(저주파)”을 결합해, 정지 상태에서의 잔노이즈를 줄이면서도 조종 입력에 대한 응답성은 유지하는 목적입니다. (Yaw는 가속도로 절대 보정이 불가하므로 초기에는 자이로 적분 위주로 운용하고, 추후 필요 시 Mag를 절대 헤딩 보정용으로 제한적으로 결합합니다.)



### 1.3 AHRS 추가 개선 사항 (Anti-Drift Logic)
노이즈를 없애기 위해 **센서 데이터 전처리 필터** 과정을 대폭 강화했습니다.

* **초기 자이로 캘리브레이션 AHRS_CalibrateOffset():**
    * 부팅 직후 1000개의 자이로 샘플을 수집하여 평균값(Bias)을 산출(`gyro_off_x, y, z`)하고, 이후 측정되는 모든 데이터에서 이 Bias를 차감하여 사용합니다.
    * 또한 캘리브레이션 완료 시점에 가속도계를 기반으로 Roll/Pitch 초기 각도를 계산하여, 필터가 0도에서 천천히 수렴하는 현상을 제거했습니다.
* **데드존(Deadzone) 적용:**
    * 캘리브레이션 후에도 남는 미세한 화이트 노이즈가 적분되어 Yaw가 흐르는 것을 방지하기 위해, 설정된 임계값(Threshold) 이하의 자이로 신호는 강제로 0으로 처리합니다.
* **AHRS 필터 설계 의도 :**
    * 현재 Mag 없이 Rate로만 제어하므로 **센서 드리프트(Drift)**를 잡는 것이 핵심입니다.
    * Bias 제거와 데드존 처리를 통해 **가만히 있는 기체가 센서 오차 때문에 회전하고 있다고 착각하는 현상을 원천 차단**하였습니다.
---

## 2. Servo & PID Control Logic 변경 사항
비행 안전성을 높이고, 이륙 시 드론이 뒤집히는 현상을 방지하기 위해 Takeoff Latch(이륙 판정) 및 **Yaw 제어 수정**을 단행했습니다.

### 2.1 이륙 판정 로직 (Takeoff Latch / Air Mode Logic)
PID 제어기의 적분항(I-term)이 땅에 있는 동안 비정상적으로 누적되는 것을 방지합니다.

* **상태 변수:** `s_is_airborne` (0: 지상, 1: 공중)
* **동작 로직:**
    * **이륙 감지:** 스로틀(Throttle) > 1450us일 경우 `s_is_airborne = 1`로 전환 (I-term 정상 작동).
    * **착륙/초기화:** 스로틀 < 1050us일 경우 `s_is_airborne = 0`으로 전환하며 모든 PID 적분항 초기화.
    * **지상 아이들링 (1050 < Thr < 1450):** 시동은 걸렸으나 이륙하지 않은 상태. P, D 제어는 수행하되 I-term(적분)은 강제로 0으로 고정.
* **효과:** 이륙 직전 기체가 기울어져 있어도 I-term이 쌓이지 않아, 스로틀을 올리는 순간 급격하게 뒤집히는 사고를 예방합니다. 현재 진동이 강해서 그러지 호버링 자체는 가능 

### 2.2 Yaw Axis 제어 최적화 (Rate Only)
Yaw 축에 대한 **Angle 제어를 끄고, 오로지 Rate 제어에만 의존**하도록 변경했습니다.

* **Yaw Angle Loop OFF:**
    * 이륙 전이나 호버링 중 Yaw가 흔들릴 때, Angle 제어가 켜져 있으면 P, I항이 계속 보정하려고 개입하여 불필요한 서보 움직임을 유발합니다.
    * 따라서 호버링 시 **Heading Hold(각도 유지)보다는 회전 억제**가 중요하므로 Angle 제어 자체를 제거.
* **Yaw Rate I-term Minimization:**
    * 단순 호버링 상태에서 Yaw I항은 불필요하다고 판단되어 최소화했습니다.
---



## 프로젝트 수정 방향 (개론)

본 프로젝트에서 필자는 **드론의 호버링 성공**을 최우선 목표로 두었다.  
드론에 기능을 추가하기전 가장 선행되어야 되는것은 “일단 안정적으로 뜨는가”가 라고 판단했다.

그래서 호버링에 필요 없는 요소들은 최대한 제거하고,  
불안정하다고 판단되는 구조는 전부 단순하고 안전한 방향으로 수정했다.
핵심 오류 수정이나 개선사항을 아래에 작성한다.

---

### 1. Timer14 마이크로초(us) 파라미터 오류
기존 코드에서는 Timer14를 이용해 마이크로초(us)를 관리하는 과정에서  
psc = 0 , arr = 83으로 두어
**1초에 약 100만 번의 인터럽트가 발생하는 구조**가 사용되고 있었다.

이로 인해 시스템이 너무 자주 과부하 상태가 되었고,  
실제로 HardFault가 반복적으로 발생했다.

이제 더이상 Timer14 인터럽트 기반 us 증가 방식을 사용하지 않는다.
timer을 psc = 83 Arr = 65535 로 둔다. 
그 후 us 단위가 필요한 함수는 전부 카운터 캡처 LL_TIM_GetCounter(TIM14)로 마이크로초를 측정하는 방식으로 수정하였다.
-> 전부 이상 없고 정확도도 매우 향상되었다. 

---

### 2. RC 프로토콜 구조 문제 (PPM 전용으로 단순화)
기존 RC 코드는 여러 RC 프로토콜을 고려한 구조였고,  
동적 할당, 복잡한 분기, 잦은 flag 변경(ppm기준)이 포함되어 있었다.

하지만 현재 프로젝트에서는 **PPM 조종기만 사용**할 예정이며,  
호버링 단계에서 이러한 복잡성은 오히려 위험 요소라고 판단했다.

특히 ppm 인터럽트가 발생할 때마다 flag가 안전하지 않은 상태에서도 자주 올라가면서 
RC 초기화 및 캘리브레이션 과정이 정상적으로 완료되지 않는 문제가 있었다.
(기존 코드는 인터럽트가 발생할때마다 setflag가 됨. 안전성 판단 불가)
(기존 RC_init과 칼리브레이션 함수에도 문제가 있음. RC init에서 RC_enterESCcalibration()가 스로틀 체크 5초동안 대기하고 실패했을때만 실행이됨. 즉 RC초기화에 성공했을때 칼리브레이션이 전혀 일어나지 않는상황. 
또한 RC_enterESCcalibration()또한 칼리브레이션을 100퍼센트 보장할 수 없음)
이에 따라,
- RC 구조를 PPM 전용으로 단순화
- 동적 할당 및 불필요한 프로토콜 분기 제거
- **완전히 안전한 상태에서만 flag가 올라가도록 수정** (싱크로 블랭크 타임이 됐을 때 채널 cnt가 무조건 8이 되고, 임시 채널 저장 배열 ppm_work[] 에 8채널 전부 값이 다 들어온 상태에서만 flag 가 세워지고, 그 이후 버퍼로 넘깁니다) 
- RC 초기화 및 캘리브레이션 과정 안정화 
- `param_load` 내 `setPPM()` 관련 오류 수정
(setPPM에서는 RC 채널 MIN MAX값을 설정해주는 함수가 빠져있음. 그래서 RC에서 RC_MSG_setChannelValue(value, i) 부분이 계속해서 오류발생. 값이 0이 되어버림)
등을 통해 RC 입력을 최대한 안전하게 개선하였다.

여러 RC 프로토콜 지원과 RC IRQ HANDLER는 **일단 호버링 성공이 보장되는 상황에서** 안전하게 기존의 코드 방식대로 만들 예정이다. 

---

### 3. Yaw 계산 방식 문제
기존 코드에서는 yaw가  
지자계 센서 + IMU roll/pitch 값을 함께 사용해 계산되고 있었다.

그러나 roll/pitch 변화에 따라 yaw 값이 크게 흔들리는 심각한 오류가 지속해서 발생했다.

여러 방식으로 보정을 시도했지만, 
결론적으로 **지자계 센서는 신뢰하기 어렵다고 판단**하였다.

따라서 현재는:
- yaw를 IMU 기반으로만 계산
- drift가 발생하더라도 일단 IMU만 사용하는 방식 채택
- 실제 테스트 결과 IMU의 정밀도가 충분하다고 판단 (현재 정도의 drift는 호버링에 전혀 문제없음)

지자계 센서를 이용한 보정은  
**호버링 성공 이후에 추가하는 방향**으로 결정하였다.

---

### 4. 서보 제어기 구조 문제 (가장 중요한 문제)
기존 코드에 두가지 문제가 있다.
첫번째는 Yaw 제어가 없다는것. 
Yaw는 CW, CCW의 토크 제어로 이루어지는데 Yaw 제어는 아예 없다. 

두번째로, 기존 코드에서 가장 큰 문제는  
**조종기 입력이 모터 출력에 직접 연결되어 있었다는 점**이다.


조종기는 절대 모터 출력을 직접 제어하면 안 된다.  
조종기의 역할은 **목표 자세를 정하는 것**뿐이다.

일반적인 드론 제어 방식은 다음과 같다.

- 조종기 입력 → 목표 자세 설정
- IMU로 현재 자세 측정
- 목표 자세와 현재 자세의 오차 계산
- PID 제어기로 보정
- 그 결과를 모터에 적용

하지만 기존 코드는  
조종기 값을 그대로 모터 출력에 더하는 방식이었고,  
이로 인해 자세 제어가 근본적으로 불가능하다.

또한 드론 제어는 각도를 기준으로 오차를 더하고 빼서 맞추는 구조가 아니다.
대부분의 상용 드론은 **각속도(rate) 기반 내부 PID 루프**를 사용한다.

bldc 모터 출력 오차 관련해서는
대부분의 상용 드론은 IMU 기반 피드백 제어를 사용하며,  
각 모터의 RPM에 오차가 있더라도  
**pid 제어기가 자세 오차를 기준으로 자동으로 보정**한다.
(만약 한쪽 모터가 약하다면 만족하는 자세가 나오지 않을것이고, 그 자세를 만들기 위해 제어기가 한쪽 모터를 더 강하게 돌려 만족하는 자세를 충족시킨다)
즉,
- 모터 RPM을 직접 맞출 필요는 없고
- 중요한 것은 목표 자세를 만족시키는 것

따라서 서보 제어기는  
조종기 → 목표 자세 → IMU → PID → 출력  
이라는 정상적인 구조로 수정하는 방향으로 진행했다.


---

현재 코드의 제어기 테스트를 하고싶다면 
기존 RC_init(), RC_GetData()를 없애버리고 
main.c에 있는 RC 스로틀 1500 가상 주입함수를 main의 while 루프에다 넣으면된다.
그후 live expression 에서 서보 채널 출력을 확인하면 된다. 

### 정리
이 프로젝트의 모든 수정은  
**호버링을 가장 먼저 성공시키기 위해서 수정되었다**
